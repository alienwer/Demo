<!--
 * @Author: LK
 * @Date: 2025-08-08 20:40:15
 * @LastEditTime: 2025-08-13 07:42:08
 * @LastEditors: LK
 * @FilePath: /Demo/.trae/rules/project_rules.md
-->

## 技术栈与依赖管理

### 1. 核心框架版本

| 组件                 | 版本        | 依赖说明                   |
| -------------------- | ----------- | -------------------------- |
| **Flexiv RDK** | `>=1.6.0` | 需显式声明，默认版本 1.6.0 |

Environment Compatibility

| **OS**          | **Platform** | **C++ compiler kit** | **Python interpreter** |
| --------------------- | ------------------ | -------------------------- | ---------------------------- |
| Linux (Ubuntu 20.04+) | x86_64, aarch64    | GCC v9.4+                  | 3.8, 3.10, 3.12              |
| macOS 12+             | arm64              | Clang v14.0+               | 3.10, 3.12                   |
| Windows 10+           | x86_64             | MSVC v14.2+                | 3.8, 3.10, 3.12              |
| QNX 8.0.2+            | x86_64, aarch64    | QCC v12.2+                 | Not supported                |

- **使用conda环境**：在进行开发时，默认使用 `conda activate demo-env` 命令来激活开发环境，确保依赖与配置的一致性。

## Flexiv RDK API中的阻塞与非阻塞函数

根据Flexiv RDK官方API文档，函数被明确标记为**[Blocking] （阻塞）或 [Non-blocking]**（非阻塞），这是区分函数类型的主要方式。

### 阻塞函数 [Blocking]

特点：

- 函数调用后会等待操作完成才返回 1
- 在操作期间程序会暂停执行
- 通常用于需要确认完成状态的操作
  典型阻塞函数：
- Robot() - 机器人控制接口实例化，会阻塞直到初始化完成并建立连接 1
- Enable() - 使能机器人，阻塞直到机器人释放制动器并变为可操作状态 1
- SwitchMode() - 切换控制模式，阻塞直到模式切换完成 1
- Stop() - 停止机器人并切换到IDLE模式，阻塞直到机器人完全停止 1
- ExecutePlan() - 执行计划，阻塞直到计划开始执行 1
- plan_list() - 获取可用计划列表，阻塞直到获取完成 1
- Brake() - 强制制动器接合或释放，阻塞直到操作完成 1
- Model::SyncURDF() - 同步URDF参数，阻塞直到同步完成 2
- Model::configuration_score() - 获取配置评分，阻塞直到收到回复 2

### 非阻塞函数 [Non-blocking]

特点：

- 函数立即返回，不等待操作完成 1
- 通常用于状态查询和数据获取
- 适合在实时循环中频繁调用
  典型非阻塞函数：
- connected() - 检查与机器人的连接状态 1
- mode() - 获取当前控制模式 1
- states() - 获取机器人状态数据（标记为Real-time RT） 1
- operational() - 检查机器人是否可操作 1
- busy() - 检查机器人是否忙碌 1
- fault() - 检查机器人是否处于故障状态 1
- estop_released() - 检查急停是否释放 1
- Model::Update() - 更新机器人模型配置 2
- Model::J() - 计算雅可比矩阵 2

### 实时(RT)与非实时(NRT)访问

Flexiv RDK提供两种访问级别： 13

实时(RT)模式：

- 提供低级别的实时访问
- 适用于需要精确时序控制的应用
- 某些函数标记为"Real-time (RT)"
  非实时(NRT)模式：
- 提供高级别的非实时访问
- 适用于一般的机器人控制任务
- 大多数阻塞函数属于此类

### 使用建议

1. 状态查询 ：使用非阻塞函数进行频繁的状态检查
2. 控制命令 ：使用阻塞函数确保命令执行完成
3. 实时应用 ：在实时循环中优先使用非阻塞函数
4. 错误处理 ：阻塞函数通常提供更详细的错误信息和异常处理
   通过API文档中的明确标记，开发者可以根据应用需求选择合适的函数类型，确保程序的性能和可靠性。

## 个人配置
1. 测试文件全部放到test目录下

